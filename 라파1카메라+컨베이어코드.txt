# file: rpi_cam1_conveyor_client.py
# ëª©ì :
#  - ì¹´ë©”ë¼ JPEG í”„ë ˆì„ì„ ì¤‘ì•™ Flask ì„œë²„ë¡œ ì—…ë¡œë“œ (/upload_frame)
#  - ì»¨ë² ì´ì–´ëŠ” ë¼ì¦ˆë² ë¦¬ì—ì„œ 'ê¸°ë³¸: 2s ì „ì§„ â†’ 1.5s ì •ì§€' ë£¨í”„
#  - ì„œë²„ì˜ "ì›í•˜ëŠ” ìƒíƒœ(start/stop)"ë¥¼ í´ë§í•˜ì—¬ ë£¨í”„ ON/OFF
#
# ì„œë²„ ì¸¡ ìš”êµ¬(ì•„ë˜ ì¤‘ í•˜ë‚˜ë§Œ êµ¬í˜„ë˜ì–´ë„ ë™ì‘):
#   GET /api/conveyor/desired  â†’ JSON { "run": true|false }  (ê¶Œì¥)
#                            ë˜ëŠ” JSON { "mode": "start"|"stop" }
#                            ë˜ëŠ” JSON { "desired": "start"|"stop" }
#                            ë˜ëŠ” í‰ë¬¸ "start" / "stop"
#
# ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë‚˜ 404ì¼ ê²½ìš°: ë§ˆì§€ë§‰ ìƒíƒœ ìœ ì§€(ì•ˆì „)

import cv2
import time
import requests
import threading
from queue import Queue, Empty
import signal
import traceback

# =========================
# êµ¬ì„±
# =========================
SERVER_HOST = "192.168.0.87"    # â˜… Flask ì„œë²„ IP (PC)
SERVER_PORT = 8000

UPLOAD_URL  = f"http://{SERVER_HOST}:{SERVER_PORT}/upload_frame"
CONTROL_URL = f"http://{SERVER_HOST}:{SERVER_PORT}/api/conveyor/desired"   # ì¡´ì¬í•˜ì§€ ì•Šì•„ë„ ë¨(ìœ ì—° íŒŒì‹±)

FRAME_W, FRAME_H, FRAME_FPS = 640, 480, 30
JPEG_QUALITY = 80
QUEUE_MAX = 2

# ì»¨ë² ì´ì–´ í•€ ë° ë£¨í”„ íƒ€ì´ë°(ê¸°ë³¸)
FORWARD_PIN = 17
BACKWARD_PIN = 27
FORWARD_SEC = 2.0
PAUSE_SEC   = 1.5

# í´ë§ ê°„ê²©/íƒ€ì„ì•„ì›ƒ
POLL_INTERVAL = 0.3     # ì„œë²„ ìƒíƒœ í™•ì¸ ì£¼ê¸°
HTTP_TIMEOUT  = 0.8

# =========================
# ì¢…ë£Œ ì´ë²¤íŠ¸
# =========================
stop_event = threading.Event()

# =========================
# ìƒíƒœ ê³µìœ 
# =========================
class SharedState:
    def __init__(self):
        self._lock = threading.Lock()
        self._should_run = True   # ê¸°ë³¸: ë£¨í”„ ON (2sâ†’1.5s)
        self._last_update_ts = 0

    def set_should_run(self, val: bool):
        with self._lock:
            self._should_run = bool(val)
            self._last_update_ts = time.time()

    def get_should_run(self) -> bool:
        with self._lock:
            return self._should_run

    def last_update_age(self) -> float:
        with self._lock:
            if self._last_update_ts == 0:
                return 1e9
            return time.time() - self._last_update_ts

state = SharedState()

# =========================
# ì¹´ë©”ë¼ ì—…ë¡œë”
# =========================
class CameraUploader:
    def __init__(self):
        self.q = Queue(maxsize=QUEUE_MAX)
        self.frame_count = 0
        self.last_stats = time.time()
        self.total_sent = 0

    def _open_camera(self):
        cap = cv2.VideoCapture(0, cv2.CAP_V4L2)
        if not cap.isOpened():
            print("âŒ ì¹´ë©”ë¼ ì—´ê¸° ì‹¤íŒ¨")
            return None
        cap.set(cv2.CAP_PROP_FRAME_WIDTH,  FRAME_W)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_H)
        cap.set(cv2.CAP_PROP_FPS,         FRAME_FPS)
        cap.set(cv2.CAP_PROP_BUFFERSIZE,  1)

        actual_w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        actual_h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        actual_fps = cap.get(cv2.CAP_PROP_FPS)
        print(f"âœ… ì¹´ë©”ë¼ ì„¤ì •: {actual_w}x{actual_h}@{actual_fps:.0f}fps")
        return cap

    def capture_loop(self):
        cap = self._open_camera()
        if cap is None:
            return
        try:
            interval = max(1.0/FRAME_FPS, 0.001)
            while not stop_event.is_set():
                ok, frame = cap.read()
                if not ok or frame is None:
                    time.sleep(0.01)
                    continue
                enc_ok, buf = cv2.imencode(".jpg", frame, [cv2.IMWRITE_JPEG_QUALITY, JPEG_QUALITY])
                if enc_ok:
                    jpg = buf.tobytes()
                    try:
                        self.q.put_nowait(jpg)
                    except:
                        try:
                            self.q.get_nowait()
                            self.q.put_nowait(jpg)
                        except:
                            pass
                self.frame_count += 1
                time.sleep(interval)
        except Exception as e:
            print("[Camera] capture_loop error:", e)
            traceback.print_exc()
        finally:
            cap.release()
            print("[Camera] ìº¡ì²˜ ì¢…ë£Œ")

    def upload_loop(self):
        sess = requests.Session()
        while not stop_event.is_set():
            try:
                jpg = self.q.get(timeout=0.2)
            except Empty:
                time.sleep(0.01)
                continue
            try:
                r = sess.post(UPLOAD_URL, data=jpg, timeout=HTTP_TIMEOUT)
                if r.status_code == 200:
                    self.total_sent += 1
            except Exception:
                pass

    def stats_loop(self):
        while not stop_event.is_set():
            time.sleep(10)
            elapsed = time.time() - self.last_stats
            fps = self.frame_count / elapsed if elapsed > 0 else 0.0
            print(f"ğŸ“Š ì—…ë¡œë“œ FPS: {fps:.1f}, ëˆ„ì  ì „ì†¡: {self.total_sent}")
            self.frame_count = 0
            self.last_stats = time.time()

# =========================
# ëª¨í„° (ë¡œì»¬ ì œì–´)
# =========================
def build_motor():
    try:
        from gpiozero import Motor
        try:
            # pigpioê°€ ìˆìœ¼ë©´ ë” ì •í™•í•œ íƒ€ì´ë°
            from gpiozero.pins.pigpio import PiGPIOFactory
            factory = PiGPIOFactory()   # ë¡œì»¬(pigpiod) ìë™ ì ‘ì†
        except Exception:
            factory = None
        m = Motor(forward=FORWARD_PIN, backward=BACKWARD_PIN, pin_factory=factory, pwm=False)
        print(f"[Conveyor] HW ì¤€ë¹„ë¨ (FWD={FORWARD_PIN}, BWD={BACKWARD_PIN})")
        return m
    except Exception as e:
        print("[Conveyor] HW ì—†ìŒ(ëª¨ì˜ëª¨ë“œ):", e)
        return None

def conveyor_loop(motor):
    """
    ìƒíƒœ(state.should_run)ì— ë”°ë¼:
      - True  â†’ (2.0s ì „ì§„ â†’ 1.5s ì •ì§€) ë£¨í”„ ë°˜ë³µ
      - False â†’ ì™„ì „ ì •ì§€ ìœ ì§€
    """
    print(f"[Conveyor] ê¸°ë³¸ ë£¨í”„: {FORWARD_SEC}s ì „ì§„ â†’ {PAUSE_SEC}s ì •ì§€ (ì„œë²„ ìƒíƒœë¡œ ON/OFF)")
    try:
        while not stop_event.is_set():
            if state.get_should_run():
                # ì „ì§„
                if motor:
                    motor.forward()
                t0 = time.time()
                while not stop_event.is_set() and (time.time() - t0) < FORWARD_SEC:
                    # ì¤‘ê°„ì— STOP ì§€ì‹œê°€ ì˜¤ë©´ ì¦‰ì‹œ ì •ì§€
                    if not state.get_should_run():
                        break
                    time.sleep(0.01)

                # ì •ì§€
                if motor:
                    motor.stop()

                # STOP ì§€ì‹œê°€ ì™”ìœ¼ë©´ ì •ì§€ ìƒíƒœ ìœ ì§€ë¡œ ì „í™˜
                if not state.get_should_run():
                    # ë°”ë¡œ ë‹¤ìŒ ë£¨í”„ë¡œ ë„˜ì–´ê°€ False ë¶„ê¸°ì—ì„œ ìœ ì§€
                    continue

                # ê¸°ë³¸ ì •ì§€ ì‹œê°„
                t1 = time.time()
                while not stop_event.is_set() and (time.time() - t1) < PAUSE_SEC:
                    if not state.get_should_run():
                        break
                    time.sleep(0.01)
            else:
                # ì›í•˜ëŠ” ìƒíƒœê°€ STOPì´ë©´ ì •ì§€ ìœ ì§€
                if motor:
                    motor.stop()
                time.sleep(0.05)
    finally:
        if motor:
            try:
                motor.stop()
                motor.close()
            except Exception:
                pass
        print("[Conveyor] ë£¨í”„ ì¢…ë£Œ")

# =========================
# ì„œë²„ í´ë§ (ì›í•˜ëŠ” ìƒíƒœ ë°›ì•„ì˜¤ê¸°)
# =========================
def _parse_desired_run(resp) -> object:
    """
    ì‘ë‹µì—ì„œ run(True/False) ì¶”ì¶œ.
    - JSON: { "run": bool } ë˜ëŠ” { "mode": "start"|"stop" } ë˜ëŠ” { "desired": "start"|"stop" }
    - í‰ë¬¸: "start"/"stop" / "on"/"off" / "1"/"0" / "true"/"false"
    ì¸ì‹ ì‹¤íŒ¨ ì‹œ None ë°˜í™˜.
    """
    try:
        js = resp.json()
        if isinstance(js, dict):
            if "run" in js:
                return bool(js["run"])
            if "mode" in js:
                return str(js["mode"]).lower() in ("start", "run", "on", "1", "true")
            if "desired" in js:
                return str(js["desired"]).lower() in ("start", "run", "on", "1", "true")
    except Exception:
        pass
    try:
        txt = resp.text.strip().lower()
        if txt in ("start", "run", "on", "1", "true", "go"):
            return True
        if txt in ("stop", "off", "0", "false", "halt"):
            return False
    except Exception:
        pass
    return None

def poll_server_loop():
    sess = requests.Session()
    backoff = POLL_INTERVAL
    while not stop_event.is_set():
        try:
            r = sess.get(CONTROL_URL, timeout=HTTP_TIMEOUT)
            if r.status_code == 200:
                desired = _parse_desired_run(r)
                if desired is not None:
                    prev = state.get_should_run()
                    if desired != prev:
                        print(f"[Conveyor] ì„œë²„ ì§€ì‹œ: {'START' if desired else 'STOP'}")
                        state.set_should_run(desired)
                backoff = POLL_INTERVAL     # ì„±ê³µí–ˆìœ¼ë©´ ê°„ê²© ë³µêµ¬
            else:
                # 404ë‚˜ ê¸°íƒ€ ì˜¤ë¥˜: ë§ˆì§€ë§‰ ìƒíƒœ ìœ ì§€
                pass
        except Exception:
            # ìˆœê°„ ì¥ì• : ë§ˆì§€ë§‰ ìƒíƒœ ìœ ì§€
            pass

        # ì ì§„ backoff (ìµœëŒ€ 2ì´ˆ)
        time.sleep(backoff)
        if backoff < 2.0:
            backoff = min(2.0, backoff + 0.1)

# =========================
# ë©”ì¸
# =========================
def main():
    print("=" * 60)
    print("ğŸ“¹ Camera Uploader + âš™ï¸ Conveyor (local loop; server-driven ON/OFF)")
    print("=" * 60)
    print(f"- ì„œë²„ ì—…ë¡œë“œ: {UPLOAD_URL}")
    print(f"- ìƒíƒœ í´ë§:   {CONTROL_URL}  (0.3s ì£¼ê¸°)")
    print(f"- ì»¨ë² ì´ì–´ ê¸°ë³¸ ë£¨í”„: forward {FORWARD_SEC}s â†’ pause {PAUSE_SEC}s")
    print("=" * 60)

    def _sig(signum, frame):
        stop_event.set()
    signal.signal(signal.SIGINT, _sig)
    signal.signal(signal.SIGTERM, _sig)

    # ì¹´ë©”ë¼ ìŠ¤ë ˆë“œë“¤
    cam = CameraUploader()
    threading.Thread(target=cam.capture_loop, daemon=True).start()
    threading.Thread(target=cam.upload_loop,  daemon=True).start()
    threading.Thread(target=cam.stats_loop,   daemon=True).start()

    # ì»¨ë² ì´ì–´ + í´ë§
    motor = build_motor()
    threading.Thread(target=conveyor_loop,   args=(motor,), daemon=True).start()
    threading.Thread(target=poll_server_loop,               daemon=True).start()

    try:
        print("ğŸš€ ì‹œì‘ë¨ (CTRL+C ì¢…ë£Œ)")
        while not stop_event.is_set():
            time.sleep(1)
    finally:
        stop_event.set()
        print("âœ… ì¢…ë£Œ ì •ë¦¬ ì™„ë£Œ")

if __name__ == "__main__":
    main()
